class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n  =  graph.length;
        parent = new int[n];
        size =  new int[n];
        Arrays.fill(size,1);
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
        // System.out.println(Arrays.toString(parent) );
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j && graph[i][j]==1){
                    union(i,j);
                }
            }
        }
        Arrays.sort(initial);
        // setLead,
        int minInfectNode =  initial[0] ,  maxSizeNode = 0 ;        
        int SetLeadToInfectCount[] =  new int[n];
        for(int infect : initial){
            int lead =  find(infect);
            SetLeadToInfectCount[lead]++;            
        }
        // System.out.println(Arrays.toString(SetLeadToInfectCount) );
        for(int infect :initial){
            int lead =  find(infect);
            if(SetLeadToInfectCount[lead] == 1 ){
                int csz =  size[lead];
                if(csz > maxSizeNode){ // means we are saving larger size component
                    maxSizeNode =  csz;
                    minInfectNode =  infect;
                }
            }
        }        
        
        return minInfectNode;
        
    }
    int parent[] ;
    int size[] ;
    private int find(int x){
        if(x!=parent[x]){
            parent[x] =  find(parent[x]);
        }
        return parent[x];
    }
    
    private void union(int x1 , int x2){
        int s1 =  find(x1);
        int s2 =  find(x2);
        
        if(size[s1] <= size[s2] ){
            parent[s1] =  s2;
            size[s2]+=size[s1];
        }
        else{
            parent[s2] =  s1;
            size[s1]+=size[s2];
        }
    }
        
}